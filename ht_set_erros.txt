The key field of the t_node structure is being overwritten with the value of the key argument, rather than being assigned to a copy of the key argument. This can cause problems if the original key string is modified or freed after it has been added to the hash table. To fix this, you can use a function like strdup to create a copy of the key string that can be used to store in the key field of the t_node structure.

The next field of the t_node structure is being overwritten with NULL at the end of the function, rather than being set to the newly-allocated t_node structure. This can cause problems if the hash table is used to store multiple nodes with the same hash value, as the next field is used to link these nodes together in a linked list. To fix this, you should set the next field to the newly-allocated t_node structure after initializing the other fields.

The key and value fields of the newly-allocated t_node structure are being assigned to the values of the key and value arguments, rather than being assigned to copies of these values. This can cause problems if the original key or value pointers are modified or freed after they have been added to the hash table. To fix this, you can use functions like strdup and malloc to create copies of the key and value data that can be used to store in the key and value fields of the t_node structure.

The ht_contains function is being called to check if the key is already present in the table before inserting the new node. However, this check is not sufficient to guarantee that the key is unique, as it is possible for two different keys to hash to the same value. To fix this, you should use the key field of the